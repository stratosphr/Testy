// TODO: Add <EOF> at the end of the pulic parsing functions

options
{
    NODE_SCOPE_HOOK = true;
    VISITOR = true;
    MULTI = true;
    VISITOR_RETURN_TYPE = "Object";
    VISITOR_DATA_TYPE = "java.util.Map<Object, Object>";
    NODE_FACTORY=false;
}

PARSER_BEGIN(BParser)
package b.parser;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

@SuppressWarnings("ALL")
public class BParser {

    private static BParser singleton;
    private static String file;

    public static void setInputFile(String file) throws ParseException, FileNotFoundException {
        BParser.file = file;
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8));
        if (singleton == null) {
            singleton = new BParser(bufferedReader);
        } else {
            BParser.ReInit(bufferedReader);
        }
    }

    public static void jjtreeOpenNodeScope(Node n) {
        ((SimpleNode) n).setSourceCoordinates(new SourceCoordinates(file, getToken(0).beginLine, getToken(0).endLine, getToken(0).beginColumn, getToken(0).endColumn));
    }

    public static void jjtreeCloseNodeScope(Node n) {
    }

}

PARSER_END(BParser)

SKIP : {
    " "
|   "\r"
|   "\t"
|   "\n"
}

TOKEN : {
    < MACHINE: "MACHINE" > |
    < EQUIV: "<=>" | "<==>" > |
    < IMPLIES: "=>" | "==>" > |
    < OR: "||" > |
    < AND: "&&" > |
    < EQ: "=" > |
    < NOT: "~" > |
    < NEQ: "!=" | "\\=" > |
    < LT: "<" > |
    < LE: "<=" > |
    < GT: ">" > |
    < GE: ">=" > |
    < IN: ":" > |
    < FALSE: "false" > |
    < TRUE: "true" > |
    < MINUS: "-"> |
    < PLUS: "+"> |
    < TIMES: "*"> |
    < DIV: "/"> |
    < MOD: "%"> |
    < NUMBER: (<DIGIT>)+ ( "." (<DIGIT>)+ )? > |   
    < DIGIT: ["0"-"9"] > |
    < ENUMVALUE: "\"" <IDENTIFIER> "\"" > |
    < IDENTIFIER: ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z", "0"-"9"])* >
}

SimpleNode parseMachine() #Machine : {
    Token name;
} {
    <MACHINE> name = <IDENTIFIER> {
        jjtThis.setValue(name.image);
        return jjtThis; 
    }
}

SimpleNode parseExpr0() #Expr : {
} {
    parseExpr1() (<EQUIV> parseExpr1() #Equiv(2))* {
        return jjtThis;
    }
}

private void parseExpr1() #void : {
} {
    parseExpr2() (<IMPLIES> parseExpr2() #Implies(2))*
}

private void parseExpr2() #void : {
} {
    parseExpr3() (<OR> parseExpr3() #Or(2))*
}

private void parseExpr3() #void : {
} {
    parseExpr4() (<AND> parseExpr4() #And(2))*
}

private void parseExpr4() #void : {
} {
    parseExpr5() (<EQ> parseExpr5() #Eq(2))*
}

private void parseExpr5() #void : {
} {
    parseExpr6() (<IN> parseExpr6() #In(2))*
}

private void parseExpr6() #void : {
} {
    parseExpr7()
    (   <LT> parseExpr7() #LT(2)
    |   <LE> parseExpr7() #LE(2)
    |   <GT> parseExpr7() #GT(2)
    |   <GE> parseExpr7() #GE(2)
    )?
}

private void parseExpr7() #void : {
} {
    parseExpr8()
    (   <PLUS> parseExpr8() #Plus(2)
    |   <MINUS> parseExpr8() #Minus(2)
    )*
}

private void parseExpr8() #void : {
} {
    parseTerminal()
    (   <TIMES> parseTerminal() #Times(2)
    |   <DIV> parseTerminal() #Div(2)
    |   <MOD> parseTerminal() #Mod(2)
    )*
}

private void parseTerminal() #void : {
    Token t;
} {
    <NOT> parseTerminal() #Not(1) |
    <MINUS> parseTerminal() #UMinus(1) |
    t = <IDENTIFIER> { jjtThis.setValue(t.image); } #Identifier(0) |
    <FALSE> #False(0) |
    <TRUE> #True(0) |
    t = <NUMBER> { jjtThis.setValue(t.image); } #Number(0) |
    "(" parseExpr0() ")" |
    LOOKAHEAD(2)
    "{" "}" #EmptySet(0) |
    "{" parseExpr0() ("," parseExpr0() #Seq(2))* "}" #Set(1)
}
